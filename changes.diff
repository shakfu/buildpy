3a4,5
> repo: https://github.com/shakfu/buildpy
> 
7c9
< - Different build configurations (static, dynamic) possible
---
> - Different build configurations (static, dynamic, framework) possible
28a31
> import argparse
38a42
> import zipfile
44c48
< __version__ = "0.0.1"
---
> __version__ = "0.0.2"
78,81c82
< if PLATFORM == "Darwin":
<     MACOSX_DEPLOYMENT_TARGET = setenv("MACOSX_DEPLOYMENT_TARGET", "12.6")
< DEFAULT_PY_VERSION = "3.12.9"
< # DEFAULT_PY_VERSION = "3.13.5"
---
> DEFAULT_PY_VERSION = "3.13.5"
83a85,99
> 
> # ----------------------------------------------------------------------------
> # platform-specific config
> 
> if PLATFORM == "Darwin":
>     MACOSX_DEPLOYMENT_TARGET = setenv("MACOSX_DEPLOYMENT_TARGET", "12.6")
>     BUILD_TYPES = [
>         "local",
>         "shared-ext",
>         "static-ext",
>         "framework-ext",
>         "framework-pkg",
>     ]
> elif PLATFORM == "Windows":
>     BUILD_TYPES = ["local", "windows-pkg"]
405c421
<         "readline",
---
>         # "readline", # disable by default for externals
427a444
>         "readline",
566c583
<             "readline",
---
>             # "readline", # already disabled by default
591c608
<             "readline",
---
>             # "readline",
723a741
>         self.log.info("downloaded %s from %s", filename, url)
729a748,755
>                 self.log.info("extracting %s to %s", archive, tofolder)
>                 if sys.version_info.minor >= 12:
>                     f.extractall(tofolder, filter="data")
>                 else:
>                     f.extractall(tofolder)
>         elif zipfile.is_zipfile(archive):
>             self.log.info("extracting %s to %s", archive, tofolder)
>             with zipfile.ZipFile(archive) as f:
731,733d756
<         # elif zipfile.is_zipfile(archive):
<         #     with zipfile.ZipFile(archive) as f:
<         #         f.extractall(tofolder)
793a817,822
>     def glob_move(self, src: Pathlike, patterns: str, dst: Pathlike):
>         """Move with glob patterns"""
>         targets = src.glob(patterns)
>         for t in targets:
>             self.move(t, dst)
> 
941,942c970,972
<         self.cwd = Path.cwd()
<         self.build = self.cwd / "build"
---
>         self.root = Path.cwd()
>         self.build = self.root / "build"
>         self.support = self.root / "support"
968a999
>     download_archive_template: str
970c1001
<     libs_static: list[str]
---
>     lib_products: list[str]
1023a1055,1064
>     def name_ver_nodot(self) -> str:
>         """return name.lower-<ver_nodot>: e.g. python311"""
>         return f"{self.name.lower()}{self.ver_nodot}"
> 
>     @property
>     def download_archive(self) -> str:
>         """return filename of archive to be downloaded"""
>         return self.download_archive_template.format(ver=self.version)
> 
>     @property
1026c1067,1069
<         return self.download_url_template.format(ver=self.version)
---
>         return self.download_url_template.format(
>             archive=self.download_archive, ver=self.version
>         )
1028a1072,1081
>     def downloaded_archive(self) -> str:
>         """return path to downloaded archive"""
>         return self.project.downloads / self.download_archive
> 
>     @property
>     def archive_is_downloaded(self) -> bool:
>         """return true if archive is downloaded"""
>         return self.downloaded_archive.exists()
> 
>     @property
1092c1145
<         return self.project.lib / self.dylib_name
---
>         return self.prefix / "lib" / self.dylib_name
1102c1155
<         return self.project.lib_static / self.staticlib_name
---
>         return self.prefix / "lib" / self.staticlib_name
1109,1111c1162,1164
<     def libs_static_exist(self) -> bool:
<         """check if all built stati libs already exist"""
<         return all((self.prefix / "lib" / lib).exists() for lib in self.libs_static)
---
>     def lib_products_exist(self) -> bool:
>         """check if all built lib_products already exist"""
>         return all((self.prefix / "lib" / lib).exists() for lib in self.lib_products)
1151,1153c1204,1211
<         archive = self.download(self.download_url, tofolder=self.project.downloads)
<         self.log.info("downloaded %s", archive)
<         if not self.src_dir.exists():
---
>         if not self.archive_is_downloaded:
>             archive = self.download(self.download_url, tofolder=self.project.downloads)
>             self.log.info("downloaded %s", archive)
>         else:
>             archive = self.downloaded_archive
>         if not self.lib_products_exist():
>             if self.src_dir.exists():
>                 self.remove(self.src_dir)
1164,1166c1222,1223
<     download_url_template = (
<         "https://www.openssl.org/source/old/1.1.1/openssl-{ver}.tar.gz"
<     )
---
>     download_archive_template = "openssl-{ver}.tar.gz"
>     download_url_template = "https://www.openssl.org/source/old/1.1.1/{archive}"
1168c1225
<     libs_static = ["libssl.a", "libcrypto.a"]
---
>     lib_products = ["libssl.a", "libcrypto.a"]
1172c1229
<         if not self.libs_static_exist():
---
>         if not self.lib_products_exist():
1185c1242,1243
<     download_url_template = "https://sourceware.org/pub/bzip2/bzip2-{ver}.tar.gz"
---
>     download_archive_template = "bzip2-{ver}.tar.gz"
>     download_url_template = "https://sourceware.org/pub/bzip2/{archive}"
1187c1245
<     libs_static = ["libbz2.a"]
---
>     lib_products = ["libbz2.a"]
1191c1249
<         if not self.libs_static_exist():
---
>         if not self.lib_products_exist():
1205c1263,1264
<     download_url_template = "http://tukaani.org/xz/xz-{ver}.tar.gz"  # not used
---
>     download_archive_template = "xz-{ver}.tar.gz"
>     download_url_template = "http://tukaani.org/xz/{archive}"  # not used
1207c1266
<     libs_static = ["liblzma.a"]
---
>     lib_products = ["liblzma.a"]
1217c1276,1278
<         if not self.src_dir.exists():
---
>         if not self.lib_products_exist():
>             if not self.src_dir.exists():
>                 self.remove(self.src_dir)
1223c1284
<         if not self.libs_static_exist():
---
>         if not self.lib_products_exist():
1253,1255c1314,1315
<     download_url_template = (
<         "https://www.python.org/ftp/python/{ver}/Python-{ver}.tar.xz"
<     )
---
>     download_archive_template = "Python-{ver}.tar.xz"
>     download_url_template = "https://www.python.org/ftp/python/{ver}/{archive}"
1318a1379
>         precompile: bool = True,
1319a1381
>         optimize_bytecode: int = -1,
1322a1385
>         is_max_package: bool = False,
1325a1389
>         self.precompile = precompile
1326a1391
>         self.optimize_bytecode = optimize_bytecode
1329a1395
>         self.is_max_package = is_max_package
1359c1425,1429
<             return self.project.install / "Python.framework" / "Versions" / self.ver
---
>             if self.is_max_package:
>                 install_dir = self.project.support
>             else:
>                 install_dir = self.project.install
>             return install_dir / "Python.framework" / "Versions" / self.ver
1364c1434
<     def python(self):
---
>     def executable(self) -> Path:
1368a1439,1443
>     def python(self):
>         """path to python3 executable"""
>         return self.executable
> 
>     @property
1375a1451,1463
>     def setup(self):
>         """setup build environment"""
>         self.project.setup()
>         if not self.archive_is_downloaded:
>             archive = self.download(self.download_url, tofolder=self.project.downloads)
>             self.log.info("downloaded %s", archive)
>         else:
>             archive = self.downloaded_archive
>         if self.src_dir.exists():
>             self.remove(self.src_dir)
>         self.extract(archive, tofolder=self.project.src)
>         assert self.src_dir.exists(), f"could not extract from {archive}"
> 
1386c1474,1477
<             prefix = self.project.install
---
>             if self.is_max_package:
>                 prefix = self.project.support
>             else:
>                 prefix = self.project.install
1441c1532
<         """zip python site-packages"""
---
>         """zip python library
1442a1534,1541
>         Precompiles to bytecode by default to save compilation time, and drops .py
>         source files to save space. Note that only same version interpreter can compile
>         bytecode. Also can specify optimization levels of bytecode precompilation:
>             -1 is system default optimization
>             0 off
>             1 drops asserts and __debug__ blocks
>             2 same as 1 and discards docstrings (saves ~588K of compressed space)
>         """
1444d1542
< 
1449d1546
<         self.move(src / "os.py", self.project.build / "os.py")
1450a1548,1562
>         if self.precompile or getenv("PRECOMPILE"):
>             self.cmd(
>                 f"{self.executable} -m compileall -f -b -o {self.optimize_bytecode} {src}",
>                 cwd=src.parent,
>             )
>             self.walk(
>                 src,
>                 match_func=lambda f: str(f).endswith(".py"),
>                 action_func=lambda f: self.remove(f),
>                 skip_patterns=[],
>             )
>             self.move(src / "os.pyc", self.project.build / "os.pyc")
>         else:
>             self.move(src / "os.py", self.project.build / "os.py")
> 
1460c1572,1575
<         self.move(self.project.build / "os.py", src / "os.py")
---
>         if self.precompile:
>             self.move(self.project.build / "os.pyc", src / "os.pyc")
>         else:
>             self.move(self.project.build / "os.py", src / "os.py")
1464c1579
<         required_pkgs = " ".join(self.pkgs)
---
>         required_pkgs = " ".join(self.required_packages)
1466c1581
<         self.cmd(f"{self.pip} install --upgrade {required_pkgs}")
---
>         self.cmd(f"{self.pip} install {required_pkgs}")
1474c1589,1591
<                 self.cmd(f"install_name_tool -id @rpath/{self.dylib_name} {dylib}")
---
>                 self.cmd(
>                     f"install_name_tool -id @loader_path/../Resources/lib/{self.dylib_name} {dylib}"
>                 )
1481,1482c1598,1604
<                 self.cmd(f"install_name_tool -id @rpath/{self.name} {dylib}")
<                 to = f"@executable_path/../{self.name}"
---
>                 if self.is_max_package:
>                     _id = f"@loader_path/../../../../support/Python.framework/Versions/{self.ver}/Python"
>                 else:
>                     _id = f"@loader_path/../Resources/Python.framework/Versions/{self.ver}/Python"
>                 self.cmd(f"install_name_tool -id {_id} {dylib}")
>                 # changing executable
>                 to = "@executable_path/../Python"
1484a1607,1617
>                 # changing app
>                 to = "@executable_path/../../../../Python"
>                 app = (
>                     self.prefix
>                     / "Resources"
>                     / "Python.app"
>                     / "Contents"
>                     / "MacOS"
>                     / "Python"
>                 )
>                 self.cmd(f"install_name_tool -change {dylib} {to} {app}")
1495a1629,1649
>     def can_run(self) -> bool:
>         """check if a run is merited"""
>         if not all(dep().lib_products for dep in self.depends_on):
>             return True  # dependencies not built
> 
>         if self.build_type == "static":
>             self.log.debug("staticlib path: %s", self.staticlib)
>             self.log.debug("staticlib exists: %s", self.staticlib.exists())
>             if not self.staticlib.exists():
>                 # staticlib not built
>                 return True
>         else:
>             self.log.debug("dylib path: %s", self.dylib)
>             self.log.debug("dylib exists: %s", self.dylib.exists())
>             if not self.dylib.exists():
>                 # staticlib not built
>                 return True
> 
>         # if all tests pass then can run
>         return False
> 
1497a1652,1657
>         if not self.can_run():
>             self.log.info("everything built: skipping run")
>             return
> 
>         self.log.info("found unbuilt dependencies, proceeding with run")
>         # run build process
1522d1681
<         # "--with-assertions",
1527d1685
<         # "--with-thread-sanitizer".
1531a1690,1702
> 
> class WindowsEmbeddablePythonBuilder(Builder):
>     """Downloads embeddable windows python"""
> 
>     name = "Python"
>     version = DEFAULT_PY_VERSION
>     repo_url = "https://github.com/python/cpython.git"
> 
>     download_archive_template = "python-{ver}-embed-amd64.zip"
>     download_url_template = "https://www.python.org/ftp/python/{ver}/{archive}"
>     depends_on = []
>     libs_static = []
> 
1533,1541c1704,1706
<     def dylib_name(self) -> str:
<         """dynamic link libname"""
<         if PLATFORM == "Darwin":
<             return f"{self.libname}d.dylib"
<         if PLATFORM == "Linux":
<             return f"{self.libname}d.so"
<         if PLATFORM == "Windows":
<             return f"{self.libname}d.dll"
<         return self.fail("platform not supported")
---
>     def install_dir(self) -> Path:
>         """return folder where binaries are installed"""
>         return self.project.support
1543,1544c1708,1715
< if __name__ == "__main__":
<     import argparse
---
>     def setup(self):
>         """setup build environment"""
>         if self.project.support.exists():
>             self.remove(self.project.support)
>         self.project.setup()
>         self.makedirs(self.project.support)
>         archive = self.download(self.download_url, tofolder=self.project.downloads)
>         self.extract(archive, tofolder=self.install_dir)
1545a1717,1925
> 
> class WindowsPythonBuilder(PythonBuilder):
>     """class for building python from source on windows"""
> 
>     config_options: list[str] = [
>         # "--disable-gil",
>         # "--no-ctypes",
>         # "--no-ssl",
>         "--no-tkinter",
>     ]
> 
>     remove_patterns: list[str] = [
>         "*.pdb",
>         "*.exp",
>         "_test*",
>         "xx*",
>         "py.exe",
>         "pyw.exe",
>         "pythonw.exe",
>         "venvlauncher.exe",
>         "venvwlauncher.exe",
>         "_ctypes_test*",
>         "LICENSE.txt",
>         "*tcl*",
>         "*tdbc*",
>         "*tk*",
>         "__phello__",
>         "__pycache__",
>         "_tk*",
>         "ensurepip",
>         "idlelib",
>         "LICENSE.txt",
>         "pydoc*",
>         "test",
>         "Tk*",
>         "turtle*",
>         "venv",
>     ]
> 
>     depends_on = []
> 
>     @property
>     def build_type(self):
>         """build type: 'static', 'shared' or 'framework'"""
>         return self.config.split("_")[0]
> 
>     @property
>     def size_type(self):
>         """size qualifier: 'max', 'mid', 'min', etc.."""
>         return self.config.split("_")[1]
> 
>     @property
>     def prefix(self):
>         """python builder prefix path"""
>         install_dir = self.project.support
>         # return install_dir / "python"
>         return install_dir
> 
>     @property
>     def libname(self):
>         """library name suffix"""
>         return f"{self.name_ver_nodot}"
> 
>     @property
>     def dylib(self) -> Path:
>         """dylib path"""
>         return self.prefix / self.dylib_name
> 
>     @property
>     def executable(self):
>         """executable path of buld target"""
>         return self.prefix / "python.exe"
> 
>     @property
>     def pip(self):
>         """path to pip3 executable"""
>         return self.prefix / "pip.exe"
> 
>     @property
>     def pth(self):
>         """syspath modifier"""
>         return f"{self.name_ver_nodot}._pth"
> 
>     @property
>     def binary_dir(self):
>         """path to folder in python source where windows binaries are built"""
>         return self.src_dir / "PCbuild" / "amd64"
> 
>     @property
>     def pyconfig_h(self):
>         """path to generated pyconfig.h header"""
>         _path = self.binary_dir / "pyconfig.h"
>         if _path.exists():
>             return _path
>         raise IOError("pyconfig.h not found")
> 
>     def pre_process(self):
>         """override by subclass if needed"""
> 
>     def can_run(self) -> bool:
>         """return true if a build or re-build is merited"""
>         return not self.dylib.exists()
> 
>     def setup(self):
>         """setup build environment"""
>         self.project.setup()
>         if not self.archive_is_downloaded:
>             archive = self.download(self.download_url, tofolder=self.project.downloads)
>             self.log.info("downloaded %s", archive)
>         else:
>             archive = self.downloaded_archive
>         if self.src_dir.exists():
>             self.remove(self.src_dir)
>         self.extract(archive, tofolder=self.project.src)
>         assert self.src_dir.exists(), f"could not extract from {archive}"
> 
>     def configure(self):
>         """configure build"""
> 
>     def build(self):
>         """main build process"""
>         self.cmd("PCbuild\\build.bat -e --no-tkinter", cwd=self.src_dir)
> 
>     def install(self):
>         """install to prefix"""
>         if not self.binary_dir.exists():
>             raise IOError("Build error")
>         if self.prefix.exists():
>             self.remove(self.prefix)
>         self.copy(self.binary_dir, self.prefix)
>         self.copy(self.src_dir / "Include", self.prefix / "include")
>         self.move(self.prefix / "pyconfig.h", self.prefix / "include")
>         self.copy(self.src_dir / "Lib", self.prefix / "Lib")
>         self.move(self.prefix / "Lib" / "site-packages", self.prefix)
>         self.makedirs(self.prefix / "libs")
>         self.glob_move(self.prefix, "*.lib", self.prefix / "libs")
>         with open(self.prefix / self.pth, "w") as f:
>             print("Lib", file=f)
>             print(f"{self.name_ver_nodot}.zip", file=f)
>             print("site-packages", file=f)
>             print(".", file=f)
> 
>     def clean(self):
>         """clean installed build"""
>         self.remove(self.prefix / "pybuilddir.txt")
>         self.glob_remove(
>             self.prefix,
>             self.remove_patterns,
>             skip_dirs=[".git"],
>         )
> 
>     def ziplib(self):
>         """zip python library
> 
>         Precompiles to bytecode by default to save compilation time, and drops .py
>         source files to save space. Note that only same version interpreter can compile
>         bytecode. Also can specify optimization levels of bytecode precompilation:
>             -1 is system default optimization
>             0 off
>             1 drops asserts and __debug__ blocks
>             2 same as 1 and discards docstrings (saves ~588K of compressed space)
>         """
>         src = self.prefix / "Lib"
>         if self.precompile or getenv("PRECOMPILE"):
>             self.cmd(
>                 f"{self.executable} -m compileall -f -b -o {self.optimize_bytecode} Lib",
>                 cwd=self.prefix,
>             )
>             self.walk(
>                 src,
>                 match_func=lambda f: str(f).endswith(".py"),
>                 action_func=lambda f: self.remove(f),
>                 skip_patterns=[],
>             )
>         zip_path = self.prefix / self.name_ver_nodot
>         shutil.make_archive(str(zip_path), "zip", str(src))
>         self.remove(src)
> 
>     def install_pkgs(self):
>         """install python packages"""
>         # required_pkgs = " ".join(self.required_packages)
>         # self.cmd(f"{self.python} -m ensurepip")
>         # self.cmd(f"{self.pip} install {required_pkgs}")
> 
>     def post_process(self):
>         """override by subclass if needed"""
>         self.log.info("%s DONE", self.config)
> 
>     def process(self):
>         """main builder process"""
>         if not self.can_run():
>             self.log.info("everything built: skipping run")
>             return
> 
>         self.pre_process()
>         self.setup()
>         self.configure()
>         self.build()
>         self.install()
>         self.clean()
>         self.ziplib()
>         # if self.pkgs:
>         #     self.install_pkgs()
>         self.post_process()
> 
> 
> def main():
>     """commandline api entrypoint"""
> 
1554a1935
>     opt("-b", "--optimize-bytecode", help="set optimization levels -1 .. 2 (default: %(default)s)", type=int, default=-1)
1557,1558c1938,1942
<     opt("-o", "--optimize", help="optimize build", action="store_true")
<     opt("-p", "--pkgs", help="install pkgs", type=str, nargs="+", metavar="PKG")
---
>     opt("-e", "--embeddable-pkg", help="install python embeddable package", action="store_true")
>     opt("-i", "--install", help="install python pkgs", type=str, nargs="+", metavar="PKG")
>     opt("-m", "--max-package", help="max package build", action="store_true")
>     opt("-o", "--optimize", help="enable optimization during build",  action="store_true")
>     opt("-p", "--precompile", help="precompile stdlib to bytecode", action="store_true")
1563c1947,1948
<     opt("-s", "--json", help="serialize config to json file")
---
>     opt("-s", "--json", help="serialize config to json file", action="store_true")
>     opt("-t", "--type", help="build based on build type")
1567,1569c1952,1999
<     python_builder_class: type[PythonBuilder] = PythonBuilder
<     if args.debug:
<         python_builder_class = PythonDebugBuilder
---
>     if PLATFORM == "Darwin":
>         python_builder_class: type[PythonBuilder] = PythonBuilder
>         if args.debug:
>             python_builder_class = PythonDebugBuilder
> 
>     elif PLATFORM == "Windows":
>         if args.embeddable_pkg:
>             builder = WindowsEmbeddablePythonBuilder()
>             builder.setup()
>             sys.exit(0)
>         else:
>             python_builder_class = WindowsPythonBuilder
> 
>     else:
>         raise NotImplementedError("script only works on MacOS and Windows")
> 
>     if args.type and args.type in BUILD_TYPES:
>         if args.type == "local":
>             sys.exit(0)
>         cfg = {
>             "shared-ext": "shared_mid",
>             "static-ext": "static_mid",
>             "framework-ext": "framework_mid",
>             "framework-pkg": "framework_mid",
>             "windows-pkg": "shared_max",
>         }[args.type]
>         is_max_package = args.type[-3:] == "pkg"
>         builder = python_builder_class(
>             version=args.version,
>             config=cfg,
>             precompile=args.precompile,
>             optimize=args.optimize,
>             optimize_bytecode=args.optimize_bytecode,
>             pkgs=args.install,
>             cfg_opts=args.cfg_opts,
>             jobs=args.jobs,
>             is_max_package=is_max_package,
>         )
>         if args.reset:
>             builder.remove("build")
>         builder.process()
>         sys.exit(0)
> 
>     if "-" in args.config:
>         _config = args.config.replace("-", "_")
>     else:
>         _config = args.config
> 
1572c2002,2003
<         config=args.config,
---
>         config=_config,
>         precompile=args.precompile,
1574c2005,2006
<         pkgs=args.pkgs,
---
>         optimize_bytecode=args.optimize_bytecode,
>         pkgs=args.install,
1576a2009
>         is_max_package=args.max_package,
1591a2025,2028
> 
> 
> if __name__ == "__main__":
>     main()
